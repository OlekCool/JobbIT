Цей документ описує налаштування та використання лінтерів у нашому проєкті для забезпечення консистентності 
стилю коду, виявлення потенційних помилок та покращення загальної якості кодової бази.

# Обрані лінтери (один для Java та інший для JavaScript): #

## Checkstyle: ##
Інструмент для дотримання стилю кодування, заданого певними правилами 
(наприклад, існує Google Java Style, Java Code Conventions). Корисний при розробці проекту у командах, 
оскільки допомагає дотриматися одного стилю при написанні великого проекту. Може здійснити перевірку 
імен змінних, класів, методів, перевірку відступів та довжини рядку, наявність Javadoc, перевірку згідно 
кастомних правил в конфігурації. Конфігураційний файл має розширення xml. 
Легка інтеграція з maven/gradle, git, IntelliJ IDEA

## ESLint: ##
Основний інструмент для статичного аналізу JavaScript, TypeScript та коду фреймворків. 
Він дозволяє налаштовувати правила стилю, знаходити синтаксичні помилки, погані практики програмування. 
Поєднується з плагіном eslint-plugin-vue (йде вже перевірка специфічна для фреймворка), eslint-plugin-security 
(виявляє потенційні проблеми з вразливостями коду). Конфігурується файлом у форматі json.

# Базові правила щодо лінтерів: #
## Checkstyle: ##
Конфігураційний файл checkstyle.xml містить такі налаштування:
Детальна документація файлу checkstyle.xml
Цей документ детально описує конфігураційний файл checkstyle.xml, який використовується лінтером Checkstyle для перевірки стилю коду у вашому Java-проєкті. Файл визначає набір правил та їх параметри, яким повинен відповідати ваш код.

### Кореневий елемент <module name="Checker"> ###
Елемент <module name="Checker"> є кореневим елементом конфігураційного файлу Checkstyle. 
Він діє як контейнер для всіх інших модулів перевірок.

### Модулі верхнього рівня (безпосередні дочірні елементи <Checker>): ###
Ці модулі застосовуються до всього проєкту на рівні файлів.
- <module name="LineLength">: перевіряє максимальну довжину рядка коду
- <module name="BeforeExecutionExclusionFileFilter">: Виключає файли з перевірки перед початком аналізу
- <property name="fileExtensions" value="java, properties, xml"/>: Вказує розширення файлів, які Checkstyle повинен аналізувати
- <module name="NewlineAtEndOfFile">: Перевіряє наявність символу нового рядка в кінці кожного файлу
- <module name="RegexpSingleline">: Шукає рядки, що відповідають заданому регулярному виразу
- <module name="TreeWalker">: Цей модуль є контейнером для правил, які застосовуються 
до структури коду Java (класів, методів, змінних тощо). Він обходить абстрактне синтаксичне дерево Java-коду.

### Модулі всередині <module name="TreeWalker"> (описані не всі, бо їх багато): ###
#### Правила іменування: ####
- <module name="ConstantName"/>: Перевіряє імена констант (статичних фінальних полів) на відповідність стандарту
- <module name="LocalFinalVariableName"/>: Перевіряє імена локальних фінальних змінних на відповідність стандарту
- <module name="LocalVariableName"/>: Перевіряє імена локальних змінних на відповідність стандарту
- <module name="MemberName"/>: Перевіряє імена нестатичних полів класу на відповідність стандарту
- <module name="MethodName"/>: Перевіряє імена методів на відповідність стандарту
- <module name="PackageName"/>: Перевіряє імена пакетів на відповідність стандарту
- <module name="ParameterName"/>: Перевіряє імена параметрів методів на відповідність стандарту
- <module name="StaticVariableName"/>: Перевіряє імена статичних нефінальних змінних на відповідність стандарту
- <module name="TypeName"/>: Перевіряє імена класів, інтерфейсів, enum'ів та анотацій на відповідність стандарту

#### Правила імпортів: ####
- <module name="AvoidStarImport">: Забороняє використання wildcard-імпортів (імпорти із .*)
- <module name="IllegalImport"/>: Забороняє імпорт певних пакетів або класів, які вважаються небажаними в проєкті
- <module name="RedundantImport"/>: Виявляє імпорти, які є зайвими (наприклад, імпорт класу з того ж пакета
- <module name="UnusedImports">: Виявляє імпорти, які не використовуються у файлі.

#### Правила пробілів: ####
- <module name="EmptyForIteratorPad"/>: Перевіряє наявність або відсутність пробілів між круглими дужками 
та крапкою з комою у порожньому ітераторі циклу for
- <module name="GenericWhitespace"/>: Перевіряє наявність правильних пробілів навколо параметризованих типів
- <module name="MethodParamPad"/>: Перевіряє наявність пробілів навколо круглих дужок у визначенні та виклику методу
- <module name="NoWhitespaceAfter"/>: Забороняє пробіли після певних токенів (наприклад, після відкриваючої круглої дужки)
- <module name="NoWhitespaceBefore"/>: Забороняє пробіли перед певними токенами (наприклад, перед закриваючою круглою дужкою)
- <module name="OperatorWrap"/>: Контролює розміщення операторів при перенесенні рядка (на початку або в кінці рядка)
- <module name="TypecastParenPad"/>: Перевіряє наявність пробілів навколо круглих дужок при приведенні типів
- <module name="WhitespaceAround"/>: Перевіряє наявність пробілів навколо бінарних операторів, ключових слів тощо

## ESLint: ##
Конфігураційний файл .eslintrc.json включає у собі певні правила:
- Щодо стилю коду
- Щодо потенційних помилок
- Щодо Best practices
- Щодо ECMAScript
- та багато інших.
Файл генерується сам при введенні команди npx eslint –init. Властивості вказуються у алфавітному порядку.

# Як запустити лінтери на перевірку коду: #
## Backend-проект ##
Можна виконати команду mvn clean verify (перевірка з білдом), або напряму запустити лінтер mvn checkstyle:check
Також можна запустити з IntelliJ IDEA через плагін 

## Frontend-проект ##
У файлі проекту package.json є опція "scripts", всередині якої прописані команди для запуску. Серед них і команда 
"lint": "vue-cli-service lint" (так як я ініціалізовував фронтенд на vue@cli). Сам лінтер запускається через 
npm run lint або ж yarn lint

# Про git hooks: #
Для автоматичної перевірки стилю коду перед кожним комітом налаштовується Git hook pre-commit. Цей hook буде запускати 
Checkstyle проекту і забороняти коміт, якщо будуть виявлені порушення правил лінтингу, незалежно від того, чи backend, 
чи frontend.

Щоб здійснити це, треба у папці .git (вона прихована), дотати файл pre-commit. І туди внести код:
#!/bin/sh

echo "Running Checkstyle..."
cd jobbit-back
mvn clean verify
CHECKSTYLE_STATUS=$?

if [ $CHECKSTYLE_STATUS -ne 0 ]; then
echo "Checkstyle found errors. Commit canceled"
exit 1
else
echo "Checkstyle successfully passed."
fi

cd ..
echo "Running ESLint..."
cd jobbit-client
npm run lint
ESLINT_STATUS=$?

if [ $ESLINT_STATUS -ne 0 ]; then
echo "ESLint found errors. Commit canceled"
exit 1
else
echo "ESLint successfully passed."
fi

exit 0

# Інтеграція з процесом збірки #
Checkstyle вже інтегровано в цей процес. У pom.xml підключено плагін maven-checkstyle-plugin. У <configLocation> тезі 
вказано шлях до конфігураційного файлу

# Статична типізація #
Хоча Checkstyle в першу чергу фокусується на стилі коду, статична типізація є фундаментальною характеристикою мови Java, 
яку використано у розробці. Статична типізація означає, що типи змінних визначаються на етапі компіляції, а не під 
час виконання. Java і є такою мовою, тож для неї це не треба налаштовувати.

Інша ситуація з JavaScript. Статичну типізацію додає TypeScript - дозволяє явно оголошувати типи змінних, параметрів
функцій, властивостей об'єктів. Встановити TypeScript можна командою npm install --save-dev typescript@types/node
і далі ініціалізувати конфігураційний файл tsconfig.json командою 
npx tsc --init --rootDir src --outDir dist --esModuleInterop –sourceMap. І фінально, надалі створювати файли з розширенням
.ts замість .js
